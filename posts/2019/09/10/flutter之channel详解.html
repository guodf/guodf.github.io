<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>flutter之channel详解 | 在路上</title>
    <meta name="description" content="This is my blog">
    <link rel="icon" href="/logo.jpg">
    <link rel="preload" href="/assets/css/0.styles.29177b02.css" as="style"><link rel="preload" href="/assets/js/app.93dd95e8.js" as="script"><link rel="preload" href="/assets/js/6.2c2a596a.js" as="script"><link rel="preload" href="/assets/js/24.1fa5da2b.js" as="script"><link rel="prefetch" href="/assets/js/1.a7adf9e5.js"><link rel="prefetch" href="/assets/js/10.8ae3113a.js"><link rel="prefetch" href="/assets/js/11.c3dc659b.js"><link rel="prefetch" href="/assets/js/12.9f877708.js"><link rel="prefetch" href="/assets/js/13.8e2e00c3.js"><link rel="prefetch" href="/assets/js/14.fa150e9a.js"><link rel="prefetch" href="/assets/js/15.bcc48a3b.js"><link rel="prefetch" href="/assets/js/16.69d51cda.js"><link rel="prefetch" href="/assets/js/17.ae0b8996.js"><link rel="prefetch" href="/assets/js/18.78e1af87.js"><link rel="prefetch" href="/assets/js/19.a228787d.js"><link rel="prefetch" href="/assets/js/20.2e2562c9.js"><link rel="prefetch" href="/assets/js/21.44d9ef72.js"><link rel="prefetch" href="/assets/js/22.b6de3270.js"><link rel="prefetch" href="/assets/js/23.7e0f3d0e.js"><link rel="prefetch" href="/assets/js/25.a46c4df0.js"><link rel="prefetch" href="/assets/js/26.29bef09c.js"><link rel="prefetch" href="/assets/js/27.28879391.js"><link rel="prefetch" href="/assets/js/28.34521276.js"><link rel="prefetch" href="/assets/js/29.f6cc17c9.js"><link rel="prefetch" href="/assets/js/3.a50e10c9.js"><link rel="prefetch" href="/assets/js/30.ab82eebf.js"><link rel="prefetch" href="/assets/js/31.f1bd976f.js"><link rel="prefetch" href="/assets/js/32.4f67e237.js"><link rel="prefetch" href="/assets/js/33.fc543e8c.js"><link rel="prefetch" href="/assets/js/34.808119be.js"><link rel="prefetch" href="/assets/js/35.30ad9e84.js"><link rel="prefetch" href="/assets/js/36.4eb309d3.js"><link rel="prefetch" href="/assets/js/37.2bc86a16.js"><link rel="prefetch" href="/assets/js/38.0ac46a64.js"><link rel="prefetch" href="/assets/js/39.14d9298f.js"><link rel="prefetch" href="/assets/js/4.676f402d.js"><link rel="prefetch" href="/assets/js/40.5fdb1194.js"><link rel="prefetch" href="/assets/js/41.224746ab.js"><link rel="prefetch" href="/assets/js/42.42c216ed.js"><link rel="prefetch" href="/assets/js/43.3d44268b.js"><link rel="prefetch" href="/assets/js/44.a9c31e06.js"><link rel="prefetch" href="/assets/js/45.4a6662d8.js"><link rel="prefetch" href="/assets/js/46.054e2570.js"><link rel="prefetch" href="/assets/js/47.2db792a0.js"><link rel="prefetch" href="/assets/js/48.cbd59f67.js"><link rel="prefetch" href="/assets/js/49.a99655d1.js"><link rel="prefetch" href="/assets/js/5.00ef1290.js"><link rel="prefetch" href="/assets/js/50.65b5519b.js"><link rel="prefetch" href="/assets/js/51.040e4c3e.js"><link rel="prefetch" href="/assets/js/52.327a5580.js"><link rel="prefetch" href="/assets/js/53.daaad213.js"><link rel="prefetch" href="/assets/js/54.466c99ff.js"><link rel="prefetch" href="/assets/js/55.8b150ba0.js"><link rel="prefetch" href="/assets/js/56.9e781a43.js"><link rel="prefetch" href="/assets/js/57.8c1d75b4.js"><link rel="prefetch" href="/assets/js/58.65e427ee.js"><link rel="prefetch" href="/assets/js/59.0eda4016.js"><link rel="prefetch" href="/assets/js/60.d0d2139b.js"><link rel="prefetch" href="/assets/js/61.e2b532f7.js"><link rel="prefetch" href="/assets/js/62.4528d6a4.js"><link rel="prefetch" href="/assets/js/63.d2f0beb0.js"><link rel="prefetch" href="/assets/js/64.03ad45f8.js"><link rel="prefetch" href="/assets/js/65.c0ada4b1.js"><link rel="prefetch" href="/assets/js/66.3c151575.js"><link rel="prefetch" href="/assets/js/67.80927599.js"><link rel="prefetch" href="/assets/js/68.c6737103.js"><link rel="prefetch" href="/assets/js/69.9e3c5eb1.js"><link rel="prefetch" href="/assets/js/7.e558a805.js"><link rel="prefetch" href="/assets/js/70.1f86c7b4.js"><link rel="prefetch" href="/assets/js/71.4601e0e4.js"><link rel="prefetch" href="/assets/js/72.3b95daea.js"><link rel="prefetch" href="/assets/js/73.806e903f.js"><link rel="prefetch" href="/assets/js/74.6b263fe2.js"><link rel="prefetch" href="/assets/js/75.c0fb9b83.js"><link rel="prefetch" href="/assets/js/76.f5a286a1.js"><link rel="prefetch" href="/assets/js/77.10bd6c84.js"><link rel="prefetch" href="/assets/js/78.72c01b87.js"><link rel="prefetch" href="/assets/js/79.6296a15e.js"><link rel="prefetch" href="/assets/js/8.28eaf22c.js"><link rel="prefetch" href="/assets/js/9.f5a79d17.js">
    <link rel="stylesheet" href="/assets/css/0.styles.29177b02.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" data-v-0be91240><div data-v-3e9833e9 data-v-0be91240><nav class="navbar" data-v-3e9833e9><div class="container" data-v-3e9833e9><a href="/" class="router-link-active" data-v-3e9833e9><span class="navbar-site-name" data-v-3e9833e9>
          在路上
        </span></a> <div class="navbar-toggler" data-v-3e9833e9><svg class="icon" style="font-size:1.2em;" data-v-3e9833e9 data-v-3e9833e9><title data-v-3e9833e9 data-v-3e9833e9>menu</title><use xlink:href="#icon-menu" data-v-3e9833e9 data-v-3e9833e9></use></svg></div> <div class="navbar-links" data-v-3e9833e9><a href="/" class="navbar-link" data-v-3e9833e9>
            首页
          </a><a href="/posts/" class="navbar-link router-link-active" data-v-3e9833e9>
            足迹
          </a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-3e9833e9></div></div> <div class="banner" data-v-98d6aa8c data-v-0be91240 data-v-0be91240><div class="container" data-v-98d6aa8c><div class="center" data-v-98d6aa8c><h1 data-v-98d6aa8c data-v-0be91240>
          flutter之channel详解
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-6e91a59a data-v-6e91a59a><main class="main" data-v-6e91a59a><div class="post" data-v-6e91a59a data-v-6e91a59a><section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2019-09-10
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2019-09-17
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2019/09/10/android%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6.html" class="post-link" data-v-4e23451f>
      上一篇 : Android引入第三方jar包
    </a> <a href="/posts/2019/09/10/android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html" class="post-link" data-v-4e23451f>
      下一篇 : Android开发常见问题汇总
    </a></section></section> <article class="main-div"><div class="post-content content content__default"><h2 id="flutter之channel详解"><a href="#flutter之channel详解" class="header-anchor">#</a> flutter之channel详解</h2> <pre><code>flutter提供了三个channel来支持dart与原生平台的交互，channel的通信方式类似rcp调用，不同的是flutter的内部实现是通过内存拷贝的方式将原生字节流转换成dart字节流。
</code></pre> <ul><li><p><strong>MethodChannel</strong></p> <p>通过定义对应的资源名称实现与平台进行一次性通信。</p></li> <li><p><strong>EventChannel</strong></p> <p>通过流的方式，持续接收对方的通信数据，内部包装的MethodChannel。</p></li> <li><p><strong>BasicMessageChannel</strong></p> <p>与MethodChannel类似，不同的是需要指定一个解码器，这个channel与MethodChannel没有本质区别。</p></li></ul> <h3 id="交互原理"><a href="#交互原理" class="header-anchor">#</a> 交互原理</h3> <p><font color="red">channel是无状态通信，一次send/reply后调用就结束了，类似http的无状态通信</font></p> <p><img src="/flutter/channel/channel.png" alt=""></p> <h3 id="channel核心之binarymessenger"><a href="#channel核心之binarymessenger" class="header-anchor">#</a> channel核心之BinaryMessenger</h3> <p>BinaryMessenger是flutter框架给我们提供的唯一一个用于从dart到原生消息转换的工具，所有的channel都是基于BinaryMessenger进行二次包装的，具体可以看一下BinaryMessenger提供的api。</p> <h5 id="下面我们自定义一个mychannel来实现dart到原生的通信："><a href="#下面我们自定义一个mychannel来实现dart到原生的通信：" class="header-anchor">#</a> 下面我们自定义一个MyChannel来实现dart到原生的通信：</h5> <p>首先，定义个MyChannel类来包裹BinaryMessenger，实现一个channel客户端（flutter端）</p> <div class="language-dart line-numbers-mode"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">MyChannel</span> <span class="token punctuation">{</span>
    <span class="token comment">// channel客户端与服务端链接需要一个标识</span>
    <span class="token keyword">final</span> String name<span class="token punctuation">;</span>
    <span class="token comment">// channel要求通信的数据类型是ByteData</span>
    <span class="token comment">// 所以这里需要一个解码器将消息序列化/反序列化</span>
    <span class="token keyword">final</span> MessageCodec codec<span class="token punctuation">;</span>
    <span class="token comment">// 最终消息会通过该属性发送出去</span>
    <span class="token keyword">final</span> BinaryMessenger binaryMessenger<span class="token punctuation">;</span>
    <span class="token comment">// 我们直接使用Flutter提供的唯一一个BinaryMessenger，也就是defaultBinaryMessenger实例</span>
    <span class="token keyword">const</span> <span class="token function">MyChannel</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>codec<span class="token punctuation">,</span>
                    <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>binaryMessenger <span class="token operator">=</span> defaultBinaryMessenger<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    Future<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token function">send</span><span class="token punctuation">(</span>String arg<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token comment">// 先将消息序列化</span>
        <span class="token keyword">var</span> data<span class="token operator">=</span>codec<span class="token punctuation">.</span><span class="token function">encodeMessage</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> result <span class="token operator">=</span>
            <span class="token comment">//发送消息</span>
            <span class="token keyword">await</span> defaultBinaryMessenger<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
       	<span class="token comment">// 接收返回值并反序列化</span>
        <span class="token keyword">return</span> codec<span class="token punctuation">.</span><span class="token function">decodeMessage</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>然后，定义服务端（android端）</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">// 定义个channel服务端与，客户端一样，都是需要发送器，解码器，以及唯一通信标识</span>
<span class="token keyword">class</span> <span class="token function">MyChannel</span><span class="token punctuation">(</span> 
    <span class="token keyword">private</span> <span class="token keyword">val</span> binaryMessenger<span class="token operator">:</span> BinaryMessenger<span class="token punctuation">,</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> name<span class="token operator">:</span>String<span class="token punctuation">,</span> 
    <span class="token keyword">private</span> <span class="token keyword">val</span> messageCodec<span class="token operator">:</span> StringCodec<span class="token operator">=</span> StringCodec<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 与客户端不同的是服务端仅用于接收消息，所以我们要定义个消息处理类</span>
    <span class="token keyword">fun</span> <span class="token function">setHandler</span><span class="token punctuation">(</span>binaryMessageHandler<span class="token operator">:</span> MyBinaryMessageHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        binaryMessenger<span class="token punctuation">.</span><span class="token function">setMessageHandler</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> binaryMessageHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 消息处理类，收到消息后将本调用，消息处理完成后，调用reply返回响应结果</span>
<span class="token keyword">class</span> <span class="token function">MyBinaryMessageHandler</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> messageCodec<span class="token operator">:</span> StringCodec<span class="token punctuation">)</span> <span class="token operator">:</span> BinaryMessenger<span class="token punctuation">.</span><span class="token function">BinaryMessageHandler</span> <span class="token punctuation">{</span>
  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onMessage</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> ByteBuffer<span class="token operator">?</span><span class="token punctuation">,</span> reply<span class="token operator">:</span> BinaryMessenger<span class="token punctuation">.</span>BinaryReply<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> argStr<span class="token operator">=</span>messageCodec<span class="token punctuation">.</span><span class="token function">decodeMessage</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span>argStr<span class="token punctuation">)</span>
    reply<span class="token punctuation">.</span><span class="token function">reply</span><span class="token punctuation">(</span>messageCodec<span class="token punctuation">.</span><span class="token function">encodeMessage</span><span class="token punctuation">(</span>argStr<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>最后，来看一下客户端与服务的实现</p> <p><code>flutter</code></p> <div class="language-dart line-numbers-mode"><pre class="language-dart"><code><span class="token comment">// 定义一个标识为mychannel的channel</span>
<span class="token keyword">var</span> _channel<span class="token operator">=</span><span class="token function">MyChannel</span><span class="token punctuation">(</span><span class="token string">&quot;mychannel&quot;</span><span class="token punctuation">,</span><span class="token function">StringCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 发送消息</span>
<span class="token keyword">var</span> result<span class="token operator">=</span><span class="token keyword">await</span> _channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>android</code></p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">// 在onCreate方法中创建channel监听标识为mychannel的消息</span>
<span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token operator">:</span> Bundle<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token comment">// 获取BinaryMessenger</span>
    <span class="token keyword">val</span> binaryMessage<span class="token operator">=</span><span class="token function">registrarFor</span><span class="token punctuation">(</span><span class="token string">&quot;package top.guodf.channel_example&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">messenger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> channel<span class="token operator">=</span><span class="token function">MyChannel</span><span class="token punctuation">(</span>binaryMessage<span class="token punctuation">,</span><span class="token string">&quot;mychannel&quot;</span><span class="token punctuation">)</span>
    <span class="token comment">// 创建一个MyBinaryMessageHandler用来对接收到消息进行处理</span>
    channel<span class="token punctuation">.</span><span class="token function">setHandler</span><span class="token punctuation">(</span><span class="token function">MyBinaryMessageHandler</span><span class="token punctuation">(</span>StringCodec<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>至此，一个简单的自定义channel就实现了，这个例子包含了所有channel通信的原理，这是一个从flutter到android的实现，channel同样支持从android到flutter的通信，只要将上面的客户端与服务端代码反过来实现就行了，下面我们实现类似EventChannel的流实现。</p> <h4 id="myeventchannel接收服务端的持续响应"><a href="#myeventchannel接收服务端的持续响应" class="header-anchor">#</a> MyEventChannel接收服务端的持续响应</h4> <p>前面我们说了channel是一次行通信，那么怎么实现持续响应呢？这里我参考了EventChannel的实现，下面做一个简化版本的demo</p> <p><code>flutter端实现</code></p> <div class="language-dart line-numbers-mode"><pre class="language-dart"><code><span class="token comment">//在MyChannel中添加如下方法</span>
Stream<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token function">eventStream</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//定义一个Stream，供flutter端持续接收服务端的消息</span>
    <span class="token keyword">var</span> controller <span class="token operator">=</span> StreamController<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">broadcast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//这里是重点，创建一个服务端，供android调用，这个方法让flutter也变成了服务端</span>
    defaultBinaryMessenger<span class="token punctuation">.</span><span class="token function">setMessageHandler</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> controller<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> value <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">decodeMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//收到服务端消息时写入controller，监听controller.stream的都能收到通知</span>
        controller<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Future<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Future</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token comment">//这里是重点，因为channel都是一次性通信，所以我们持续的通知android端我们在等待消息</span>
        <span class="token comment">//从这里可以看到流实际是在flutter控制的</span>
        <span class="token keyword">await</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> _ <span class="token keyword">in</span> controller<span class="token punctuation">.</span>stream<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//第一次由flutter端发起调用激活事件流</span>
    <span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> controller<span class="token punctuation">.</span>stream<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><code>android端实现</code></p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">//定义一个新得handler专门用于处理事件流</span>
<span class="token keyword">class</span> <span class="token function">MyEventMessageHandler</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> channel<span class="token operator">:</span>MyChannel<span class="token punctuation">,</span> <span class="token keyword">private</span> <span class="token keyword">val</span> messageCodec<span class="token operator">:</span> StringCodec<span class="token punctuation">)</span><span class="token operator">:</span>BinaryMessenger<span class="token punctuation">.</span><span class="token function">BinaryMessageHandler</span> <span class="token punctuation">{</span>
  <span class="token annotation builtin">@SuppressLint</span><span class="token punctuation">(</span><span class="token string">&quot;SimpleDateFormat&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onMessage</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> ByteBuffer<span class="token operator">?</span><span class="token punctuation">,</span> reply<span class="token operator">:</span> BinaryMessenger<span class="token punctuation">.</span>BinaryReply<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> formatter <span class="token operator">=</span> <span class="token function">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> curDate <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> str <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>curDate<span class="token punctuation">)</span>
    <span class="token comment">//调用flutter端（因为flutter我们已经再监听了，所以可以收到消息）</span>
    channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//一次调用结束，通知flutter端</span>
    reply<span class="token punctuation">.</span><span class="token function">reply</span><span class="token punctuation">(</span>messageCodec<span class="token punctuation">.</span><span class="token function">encodeMessage</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h5 id="下面时事件流的一种错误实现"><a href="#下面时事件流的一种错误实现" class="header-anchor">#</a> 下面时事件流的一种错误实现</h5> <p>下面的实现虽然也可以让flutter端持续收到消息，但是无法更新widget*（还没有理解为什么 ）*</p> <p><code>flutter端</code></p> <div class="language-dart line-numbers-mode"><pre class="language-dart"><code><span class="token comment">//在MyChannel中添加如下方法</span>
Stream<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token function">eventStream</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//定义一个Stream，供flutter端持续接收服务端的消息</span>
    <span class="token keyword">var</span> controller <span class="token operator">=</span> StreamController<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">broadcast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//这里是重点，创建一个服务端，供android调用，这个方法让flutter也变成了服务端</span>
    defaultBinaryMessenger<span class="token punctuation">.</span><span class="token function">setMessageHandler</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> controller<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> value <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">decodeMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//收到服务端消息时写入controller，监听controller.stream的都能收到通知</span>
        controller<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Future<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//第一次由flutter端发起调用激活持续流</span>
    <span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> controller<span class="token punctuation">.</span>stream<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><code>android端的错误实现</code></p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">//定义一个新得handler专门用于处理事件流</span>
<span class="token keyword">class</span> <span class="token function">MyEventMessageHandler</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">val</span> channel<span class="token operator">:</span>MyChannel<span class="token punctuation">,</span> <span class="token keyword">private</span> <span class="token keyword">val</span> messageCodec<span class="token operator">:</span> StringCodec<span class="token punctuation">)</span><span class="token operator">:</span>BinaryMessenger<span class="token punctuation">.</span><span class="token function">BinaryMessageHandler</span> <span class="token punctuation">{</span>
  <span class="token annotation builtin">@SuppressLint</span><span class="token punctuation">(</span><span class="token string">&quot;SimpleDateFormat&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onMessage</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> ByteBuffer<span class="token operator">?</span><span class="token punctuation">,</span> reply<span class="token operator">:</span> BinaryMessenger<span class="token punctuation">.</span>BinaryReply<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//为了保证flutter端可以收到通知，我们将通知放在最前面</span>
      reply<span class="token punctuation">.</span><span class="token function">reply</span><span class="token punctuation">(</span>messageCodec<span class="token punctuation">.</span><span class="token function">encodeMessage</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">//这种方式其实也可以持续发送消息到flutter端，</span>
      <span class="token comment">//但是会导致如果flutter端无法更新widget</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">val</span> formatter <span class="token operator">=</span> <span class="token function">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span><span class="token punctuation">)</span>
        <span class="token keyword">val</span> curDate <span class="token operator">=</span> <span class="token function">Date</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">val</span> str <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>curDate<span class="token punctuation">)</span>
        <span class="token comment">//调用flutter端（因为flutter我们已经再监听了，所以可以收到消息）</span>
        channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>上面的文章已经说明了channel的同时原理及实现，至于c++部分是怎么讲dart字节与原生字节转换的我解答不了，已经超出了我的认知返回。</p> <p>如果你想让MyChannel支持多种类型，可以像MethodChannel一样将MyChannel定义为泛型的版本：<code>MyChannel&lt;T&gt;</code>。</p> <p>个人建议还是不要自定义channel，flutter提供的三种已经完全可以满足需求了。</p> <p><strong>代码在这里：https://github.com/guodf/study_flutter/tree/master/channel</strong></p></div></article> <section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2019-09-10
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2019-09-17
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2019/09/10/android%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6.html" class="post-link" data-v-4e23451f>
      上一篇 : Android引入第三方jar包
    </a> <a href="/posts/2019/09/10/android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html" class="post-link" data-v-4e23451f>
      下一篇 : Android开发常见问题汇总
    </a></section></section> <div id="post-comments" class="main-div"><!----></div></div></main> <aside class="aside" data-v-6e91a59a><div class="info-card main-div" data-v-23d90c50 data-v-6e91a59a><div class="info-card-header" data-v-23d90c50><img src="/logo.jpg" alt="Net_win(guodf)" class="info-avatar" data-v-23d90c50></div> <div class="info-card-body" data-v-23d90c50><section class="info-nickname" data-v-23d90c50>
      Net_win(guodf)
    </section> <section class="info-desc" data-v-23d90c50>逃离码农！</section> <section class="info-contact" data-v-23d90c50><!----> <!----> <!----></section></div> <div class="info-card-footer" data-v-23d90c50><section class="info-sns clearfix" data-v-23d90c50><a href="https://github.com/guodf" target="_blank" class="sns-link" data-v-23d90c50><span title="GitHub: guodf" class="sns-icon" data-v-23d90c50 data-v-23d90c50><svg class="icon" style="font-size:1.5em;" data-v-23d90c50 data-v-23d90c50><title data-v-23d90c50 data-v-23d90c50>GitHub: guodf</title><use xlink:href="#icon-github" data-v-23d90c50 data-v-23d90c50></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-6e91a59a><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>文章目录</span> <div class="post-nav-toc"><ul><li><a href="/posts/2019/09/10/flutter%E4%B9%8Bchannel%E8%AF%A6%E8%A7%A3.html#flutter之channel详解">flutter之channel详解</a><ul><li><a href="/posts/2019/09/10/flutter%E4%B9%8Bchannel%E8%AF%A6%E8%A7%A3.html#交互原理">交互原理</a></li><li><a href="/posts/2019/09/10/flutter%E4%B9%8Bchannel%E8%AF%A6%E8%A7%A3.html#channel核心之binarymessenger">channel核心之BinaryMessenger</a></li><li><a href="/posts/2019/09/10/flutter%E4%B9%8Bchannel%E8%AF%A6%E8%A7%A3.html#总结">总结</a></li></ul></li></ul></div></div> <div class="post-nav-comments"><svg class="icon"><title>comment</title><use xlink:href="#icon-comment"></use></svg> <a href="/posts/2019/09/10/flutter%E4%B9%8Bchannel%E8%AF%A6%E8%A7%A3.html#post-comments">
      评论
    </a></div></div></aside></div> <footer class="footer" data-v-f018ab8c><p class="footer-sns-links" data-v-f018ab8c><a href="https://github.com/guodf" target="_blank" class="sns-link" data-v-f018ab8c><span title="GitHub: guodf" class="sns-icon" data-v-f018ab8c data-v-f018ab8c><svg class="icon" style="font-size:25px;" data-v-f018ab8c data-v-f018ab8c><title data-v-f018ab8c data-v-f018ab8c>GitHub: guodf</title><use xlink:href="#icon-github" data-v-f018ab8c data-v-f018ab8c></use></svg></span></a></p> <p class="footer-text" data-v-f018ab8c><span data-v-f018ab8c>Powered by </span> <a href="https://github.com/vuejs/vuepress" target="_blank" data-v-f018ab8c>
      VuePress
    </a> <span data-v-f018ab8c> | </span> <a href="https://github.com/meteorlxy/vuepress-theme-meteorlxy" target="_blank" data-v-f018ab8c>
        meteorlxy
      </a></p> <!----></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.93dd95e8.js" defer></script><script src="/assets/js/6.2c2a596a.js" defer></script><script src="/assets/js/24.1fa5da2b.js" defer></script>
  </body>
</html>
