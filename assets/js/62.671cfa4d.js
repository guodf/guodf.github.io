(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{479:function(s,t,a){"use strict";a.r(t);var r=a(1),e=Object(r.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"如何开发一款代理软件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何开发一款代理软件"}},[s._v("#")]),s._v(" 如何开发一款代理软件")]),s._v(" "),a("h3",{attrs:{id:"为什么要开发一款代理软件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要开发一款代理软件"}},[s._v("#")]),s._v(" 为什么要开发一款代理软件")]),s._v(" "),a("p",[s._v("​\t因为网络环境问题，我们总是会遇到一些情况需要靠代理软件来解决，如爬虫，翻墙，公司内外网问题等。")]),s._v(" "),a("h3",{attrs:{id:"这篇文章的目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#这篇文章的目的"}},[s._v("#")]),s._v(" 这篇文章的目的")]),s._v(" "),a("p",[s._v("​\t关于socket编程相关的东西一直都是大部分程序员可望而不可及的梦，本人也不例外，虽然平时研究过一些socket编程，如聊天工具，打洞了，抓包了，arp欺骗等都研究过一些，但是最对于代理这一块来说还是知识盲区，所以花点事件研究一下，并写下此文以作备份。")]),s._v(" "),a("h3",{attrs:{id:"windows如何配置代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#windows如何配置代理"}},[s._v("#")]),s._v(" windows如何配置代理")]),s._v(" "),a("p",[a("img",{attrs:{src:"/socket/ie_proxy.png",alt:"image-20200418153825198"}})]),s._v(" "),a("p",[s._v("打开ie配置然后如图配置就可以设置代理了，以后我们电脑的所有请求都会通过如果的地址进行代理转发，当然图片对应的地址首先是一个代理服务器。")]),s._v(" "),a("p",[a("font",{attrs:{color:"red"}},[s._v(" 这里需要注意的一点是: windows现在支持http、socks4、socks4a代理，还不支持socks5")])],1),s._v(" "),a("h3",{attrs:{id:"代理是如何运作的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理是如何运作的"}},[s._v("#")]),s._v(" 代理是如何运作的")]),s._v(" "),a("p",[s._v("​\t上图中我们看到了当前常用的代理模式有http，socks4，socks5三种代理模式，socks4a是微软定义代理协议并不在标准的rfc协议之内，所以不研究了。")]),s._v(" "),a("p",[a("font",{attrs:{color:"blue"}},[a("b",[s._v("以上三种代理模式均构建在TCP协议之上")])])],1),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("### http代理\n")])])]),a("p",[s._v("​\t顾名思义，http代理是专门用在http协议上的代理软件，所有http，https等协议都会通过此代理，下面用一张图片来介绍它的运作原理：")]),s._v(" "),a("p",[s._v("​\t"),a("img",{attrs:{src:"/socket/http_proxy.png",alt:""}})]),s._v(" "),a("p",[s._v("​\t从上图中我们可以看到使用代理后http请求执行的完整过程，其中第2，第3步是http代理软件作为代理必须完成的过程。")]),s._v(" "),a("h4",{attrs:{id:"http代理如何握手的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http代理如何握手的"}},[s._v("#")]),s._v(" http代理如何握手的")]),s._v(" "),a("p",[a("img",{attrs:{src:"/socket/http_connect.png",alt:""}})]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("从上图我们可以看到，客户端代理首先询问代理服务器要连接某个地址，然后服务回复200表示允许，此时握手就完成了，剩下的就是无脑的转发用户的请求信息。\n")])])]),a("h3",{attrs:{id:"socks4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socks4"}},[s._v("#")]),s._v(" socks4")]),s._v(" "),a("p",[s._v("​\tsocks4协议与http代理协议模式一样都要先进行握手验证，然后才进行数据的发送。")]),s._v(" "),a("p",[s._v("​\tsocks4除了支持http之外还支持ftp，telnet等，具体可以查看下面的协议连接。")]),s._v(" "),a("p",[s._v("​\t协议地址："),a("a",{attrs:{href:"http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol",target:"_blank",rel:"noopener noreferrer"}},[s._v("http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol"),a("OutboundLink")],1)]),s._v(" "),a("h4",{attrs:{id:"socks4协议格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socks4协议格式"}},[s._v("#")]),s._v(" socks4协议格式")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v(" 请求连接\n       +----+----+----+----+----+----+----+----+----+----+....+----+\n       | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|\n       +----+----+----+----+----+----+----+----+----+----+....+----+\n 字节长度  1    1      2              4            可变           1\n \n# 参数说明如下：\n VN: 4\n CD:\n    1:CONNECT\n    2:BIND\n DSTPORT: 端口\n DSTIP:  ipv4/ipv6/domain\n USERID: 用户信息\n \n 请求连接响应\n         +----+----+----+----+----+----+----+----+\n         | VN | CD | DSTPORT |      DSTIP        |\n         +----+----+----+----+----+----+----+----+\n 长度       1    1      2              4\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br")])]),a("p",[a("strong",[s._v("模拟一个握手数据：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("# 下面是一次成功的握手示例\n代理客户端---\x3e代理服务器：bytes[4,1,port,ip,userid,0]\n代理客户端<---代理服务器：bytes[0,0,port,ip]\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[a("em",[s._v("文章写道这个地方，我开始想放弃对socks4的介绍，最让我头疼的是socks竟然只支持ipv4，因为它只有固定的4个字节长度，这就直接导致了socks4必然会被淘汰，不说ipv6的长度已经超过了4个字节，就连域名也不止4个字节吧，总不能让我每次发起连接的时候先将ipv6/域名解析成ipv4地址吧，这是我认为应该完全放弃socks的理由。")])]),s._v(" "),a("p",[s._v("不过它的存在自有自己的价值，简单呀，仅用于ipv4的环境似乎运行的很好。")]),s._v(" "),a("h3",{attrs:{id:"socks5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socks5"}},[s._v("#")]),s._v(" socks5")]),s._v(" "),a("p",[s._v("​\tsocks5是对ipv4一系列缺点的扩展，比如支持udp，支持安全认证，支持域名/ipv6等，具体的功能请查阅rfc文件：https://tools.ietf.org/html/rfc1928")]),s._v(" "),a("p",[s._v("​\t"),a("img",{attrs:{src:"/socket/socks5.png",alt:""}})]),s._v(" "),a("h3",{attrs:{id:"我的学习成果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我的学习成果"}},[s._v("#")]),s._v(" 我的学习成果")]),s._v(" "),a("p",[s._v("我这里完成了一个简单得例子，仅支持http和socks4两种代理方式，代码位置："),a("a",{attrs:{href:"https://github.com/guodf/easy_proxy",target:"_blank",rel:"noopener noreferrer"}},[s._v("easy_proxy"),a("OutboundLink")],1)]),s._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("​\t综上所述，其实开发一款代理软件并不难，只要搞清楚原理一切都是浮云。")]),s._v(" "),a("p",[s._v("​\t代理软件难在对协议的理解以及即时的跟进协议的变动，只有这样才能做出通用的代理来。")])])}),[],!1,null,null,null);t.default=e.exports}}]);